"""
Tobit Model
"""
# pylint: disable=C0103
from functools import partial
from typing import Optional

from jax import grad, hessian, jit, lax
import jax.numpy as jnp
from jax.scipy.stats.norm import logcdf, logpdf
from numpy.typing import NDArray
import pandas as pd

from .model import Model


class TobitModel(Model):
    """Tobit model class.

    A tobit regression model is used for data generated by a Gaussian
    distribution with all negative elements set to 0 (i.e., a censored
    or rectified Gaussian distribution).

    """

    param_names = ("mu",)
    default_param_specs = {"mu": {"inv_link": "identity"}}

    @partial(jit, static_argnums=(0,))
    def objective(self, coefs: NDArray) -> float:
        """Get negative log likelihood wrt beta.

        Assumes the Gaussian model underlying the tobit distribution is
        parameterized by mu = mat.dot(beta), with sigma fixed at 1.

        Parameters
        ----------
        coefs : NDArray
            Beta values.

        Returns
        -------
        float
            Negative log likelihood.

        """
        mat = jnp.asarray(self.mat[0])
        lin_param = self.params[0].get_lin_param(coefs, self.data, mat=mat)
        param = self.params[0].inv_link.fun(lin_param)
        weights = self.data.weights*self.data.trim_weights
        obj_param = weights*self.nll([param])
        return obj_param.sum() + self.objective_from_gprior(coefs)

    @partial(jit, static_argnums=(0,))
    def gradient(self, coefs: NDArray) -> NDArray:
        """Get gradient of negative log likelihood wrt beta.

        Assumes the Gaussian model underlying the tobit distribution is
        parameterized by mu = mat.dot(beta), with sigma fixed at 1.

        Parameters
        ----------
        coefs : NDArray
            Beta values.

        Returns
        -------
        NDArray
            Gradient of negative log likelihood.

        """
        return grad(self.objective)(coefs)

    @partial(jit, static_argnums=(0,))
    def hessian(self, coefs: NDArray) -> NDArray:
        """Get hessian of negative log likelihood wrt beta.

        Assumes the Gaussian model underlying the tobit distribution is
        parameterized by mu = mat.dot(beta), with sigma fixed at 1.

        Parameters
        ----------
        coefs : NDArray
            Beta values.

        Returns
        -------
        NDArray
            Hessian of negative log likelihood.

        """
        return hessian(self.objective)(coefs)

    @partial(jit, static_argnums=(0,))
    def nll(self, params: list[NDArray]) -> NDArray:
        """Get terms of negative log likelihood wrt mu.

        Assumes the Gaussian model underlying the tobit distribution is
        parameterized by mu = mat.dot(beta), with sigma fixed at 1.

        Parameters
        ----------
        params : list[NDArray]
            [mu = mat.dot(beta) values].

        Returns
        -------
        NDArray
            Terms of negative log likelihood.

        """
        vals = {
            "mu": params[0],
            "sigma": 1,
            "y": self.data.obs,
            "nll_terms": jnp.zeros(self.data.num_obs)
        }
        vals = lax.fori_loop(0, self.data.num_obs, _nll_term, vals)
        return vals["nll_terms"]

    @partial(jit, static_argnums=(0,))
    def dnll(self, params: list[NDArray]) -> list[NDArray]:
        """Get derivative of negative log likelihood wrt mu.

        Assumes the Gaussian model underlying the tobit distribution is
        parameterized by mu = mat.dot(beta), with sigma fixed at 1.

        Parameters
        ----------
        params : list[NDArray]
            [mu = mat.dot(beta) values].

        Returns
        -------
        list[NDArray]
            Derivatives of negative log likelihood.

        """
        return grad(lambda mu: jnp.sum(self.nll(mu)))(params)

    @partial(jit, static_argnums=(0,))
    def d2nll(self, params: list[NDArray]) -> list[list[NDArray]]:
        """Get second derivative of negative log likelihood wrt mu.

        Assumes the Gaussian model underlying the tobit distribution is
        parameterized by mu = mat.dot(beta), with sigma fixed at 1.

        Parameters
        ----------
        params : list[NDArray]
            [mu = mat.dot(beta) values].

        Returns
        -------
        list[list[NDArray][
            Second derivatives of negative log likelihood.

        """
        hess = hessian(lambda mu: jnp.sum(self.nll(mu)))(params)
        return [[jnp.diag(hess[0][0])]]

    def predict(self, df: Optional[pd.DataFrame] = None) -> pd.DataFrame:
        """Predict mu and censored mu.

        Parameters
        ----------
        df : pd.DataFrame, optional
            Prediction data. If None, use training data.

        Returns
        -------
        pd.DataFrame
            Data frame with predicted parameters.

        """
        df = super().predict(df)
        mu = jnp.asarray(df["mu"])
        df["mu_censored"] = jnp.where(mu > 0, mu, 0)
        return df


def _nll_term(ii: int, vals: dict) -> dict:
    """Get negative log likelihood term for y[ii]."""
    term = lax.cond(vals["y"][ii] > 0, _pos_term, _npos_term, *(ii, vals))
    vals["nll_terms"] = vals["nll_terms"].at[ii].set(term)
    return vals


def _pos_term(ii: int, vals: dict) -> float:
    """Get negative log likelihood term for y[ii] > 0."""
    inner = (vals["y"][ii] - vals["mu"][ii])/vals["sigma"]
    return jnp.log(vals["sigma"]) - logpdf(inner)


def _npos_term(ii: int, vals: dict) -> float:
    """Get negative log likelihood term for y[ii] <= 0."""
    return -logcdf(-vals["mu"][ii]/vals["sigma"])
